package main

import (
	"bytes"
	"fmt"
	"go/format"
  "io"
	"os"
	"path/filepath"
	"strings"

  "github.com/samuel/go-thrift/parser"
)

func (g *GoGenerator) generateEndpoint(out io.Writer, thrift *parser.Thrift) error {
  g.write(out, "// This file is automatically generated. Do not modify.\n")

  for _, k := range sortedKeys(thrift.Services) {
    svc := thrift.Services[k]
    svcName := camelCase(svc.Name)
    methodNames := sortedKeys(svc.Methods)

    for _, k := range methodNames {
      method := svc.Methods[k]
      methodName := camelCase(method.Name)

      fmt.Println(svcName, methodName)
    }
  }

  return nil
}

func (g *GoGenerator) generateEndpoints(outPath string) {
	pkgpath := filepath.Join(outPath, "endpoints")

	if err := os.MkdirAll(pkgpath, 0755); err != nil {
		g.error(err)
	}

	for path, th := range g.ThriftFiles {
		_ = g.Packages[path]
		filename := strings.ToLower(filepath.Base(path))
		for i := len(filename) - 1; i >= 0; i-- {
			if filename[i] == '.' {
				filename = filename[:i]
			}
		}
		filename += ".go"
		outfile := filepath.Join(pkgpath, filename)

		out := &bytes.Buffer{}
    if err := g.generateEndpoint(out, th); err != nil {
      g.error(err)
    }

		outBytes := out.Bytes()
		if g.Format {
			var err error
			outBytes, err = format.Source(outBytes)
			if err != nil {
				g.error(err)
			}
		}

		fi, err := os.OpenFile(outfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			os.Exit(2)
		}
		if _, err := fi.Write(outBytes); err != nil {
			fi.Close()
			g.error(err)
		}
		fi.Close()
	}
}
